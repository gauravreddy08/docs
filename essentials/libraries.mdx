---
title: 'Libraries'
description: 'Understanding libraries as the top-level container for your vector data'
---

## What is a Library?

A library is the top-level organizational unit in the Vector Database API. It serves as a container for related documents and chunks, and defines the indexing strategy used for similarity search.

<Info>
Think of a library like a database table or collection - it groups related data together and applies consistent indexing and search policies.
</Info>

## Key Properties

Every library has the following properties:

<ParamField path="id" type="UUID" required>
  Unique identifier automatically generated when the library is created
</ParamField>

<ParamField path="name" type="string" required>
  Human-readable name for the library (must be at least 1 character)
</ParamField>

<ParamField path="index_type" type="string" required>
  The indexing algorithm: `linear`, `ivf`, or `nsw` (defaults to `linear`)
</ParamField>

<ParamField path="index_params" type="object" optional>
  Configuration parameters specific to the chosen index type
</ParamField>

<ParamField path="metadata" type="object" optional>
  Key-value pairs for storing custom information about the library
</ParamField>

<ParamField path="documents" type="array" readonly>
  List of document IDs that belong to this library
</ParamField>

<ParamField path="created_at" type="datetime" readonly>
  Timestamp when the library was created
</ParamField>

## Index Types

Choose the right index type based on your performance and accuracy requirements:

<Tabs>
  <Tab title="Linear">
    **Best for:** Small datasets, exact results required
    
    - **Algorithm:** Brute-force cosine similarity search
    - **Time Complexity:** O(n) where n is number of chunks
    - **Space Complexity:** O(n × d) where d is embedding dimension
    - **Build Time:** None (no build step required)
    
    ```json
    {
      "name": "small-library",
      "index_type": "linear"
    }
    ```
    
    <Note>
    Linear search provides exact results but doesn't scale well beyond ~10,000 chunks.
    </Note>
  </Tab>
  
  <Tab title="IVF">
    **Best for:** Medium to large datasets, good balance of speed and accuracy
    
    - **Algorithm:** Inverted File with k-means clustering
    - **Time Complexity:** O(k × d) where k is probes, d is dimension
    - **Space Complexity:** O(n × d + c × d) where c is clusters
    - **Build Time:** Required (clusters vectors using k-means)
    
    ```json
    {
      "name": "medium-library",
      "index_type": "ivf",
      "index_params": {
        "n_clusters": 100,
        "n_probes": 5
      }
    }
    ```
    
    <Tip>
    Start with `n_clusters = sqrt(n_chunks)` and `n_probes = n_clusters * 0.05` for good defaults.
    </Tip>
  </Tab>
  
  <Tab title="NSW">
    **Best for:** Large datasets, fastest search times
    
    - **Algorithm:** Navigable Small World graph (HNSW-style)
    - **Time Complexity:** O(log n × d) average case
    - **Space Complexity:** O(n × M × d) where M is max connections
    - **Build Time:** Incremental (no explicit build step)
    
    ```json
    {
      "name": "large-library", 
      "index_type": "nsw",
      "index_params": {
        "M": 16,
        "ef_construction": 200,
        "ef_search": 100
      }
    }
    ```
    
    <Warning>
    NSW indexes use more memory due to graph structure but provide the fastest search performance.
    </Warning>
  </Tab>
</Tabs>

## Index Parameters

### IVF Parameters

<ParamField path="n_clusters" type="integer" default="auto">
  Number of clusters for k-means. Default is `sqrt(n_chunks)` or minimum 1.
</ParamField>

<ParamField path="n_probes" type="integer" default="1">
  Number of clusters to search during query. Higher values increase accuracy but reduce speed.
</ParamField>

<ParamField path="cluster_ratio" type="float" default="0.1">
  Alternative to `n_clusters`. Sets clusters as ratio of total chunks.
</ParamField>

### NSW Parameters

<ParamField path="M" type="integer" default="16">
  Maximum number of connections per node in the graph. Higher values improve accuracy but use more memory.
</ParamField>

<ParamField path="ef_construction" type="integer" default="200">
  Size of candidate list during index construction. Higher values improve graph quality.
</ParamField>

<ParamField path="ef_search" type="integer" default="100">
  Size of candidate list during search. Higher values improve accuracy but reduce speed.
</ParamField>

## Library Operations

### Creating Libraries

<CodeGroup>

```bash cURL
curl -X POST 'http://localhost:8000/v1/libraries/' \
  -H 'Content-Type: application/json' \
  -d '{
    "name": "research-papers",
    "index_type": "ivf",
    "index_params": {
      "n_clusters": 50,
      "n_probes": 3
    },
    "metadata": {
      "domain": "machine-learning",
      "created_by": "data-team"
    }
  }'
```

```python Python
import requests

response = requests.post('http://localhost:8000/v1/libraries/', json={
    "name": "research-papers",
    "index_type": "ivf", 
    "index_params": {
        "n_clusters": 50,
        "n_probes": 3
    },
    "metadata": {
        "domain": "machine-learning",
        "created_by": "data-team"
    }
})

library = response.json()
```

</CodeGroup>

### Listing Libraries

<CodeGroup>

```bash cURL
curl 'http://localhost:8000/v1/libraries/'
```

```python Python
libraries = requests.get('http://localhost:8000/v1/libraries/').json()
print(f"Found {len(libraries)} libraries")
```

</CodeGroup>

### Updating Libraries

You can update the name and metadata of existing libraries:

<CodeGroup>

```bash cURL
curl -X PATCH 'http://localhost:8000/v1/libraries/{library_id}' \
  -H 'Content-Type: application/json' \
  -d '{
    "name": "updated-research-papers",
    "metadata": {
      "domain": "deep-learning",
      "updated_by": "ml-team"
    }
  }'
```

```python Python
response = requests.patch(f'http://localhost:8000/v1/libraries/{library_id}', json={
    "name": "updated-research-papers",
    "metadata": {
        "domain": "deep-learning", 
        "updated_by": "ml-team"
    }
})
```

</CodeGroup>

<Warning>
You cannot change the `index_type` or `index_params` after library creation. Create a new library if you need different indexing settings.
</Warning>

## Best Practices

<AccordionGroup>
<Accordion title="Naming Conventions">
  Use descriptive, consistent names:
  
  ✅ **Good:** `customer-support-tickets`, `product-documentation`  
  ❌ **Bad:** `lib1`, `test`, `data`
  
  Consider including:
  - Domain or category (`ml-papers`, `legal-docs`)
  - Data source (`salesforce-tickets`, `wiki-articles`)
  - Update frequency (`daily-news`, `static-docs`)
</Accordion>

<Accordion title="Index Selection">
  Choose index type based on your dataset size and requirements:
  
  - **< 1,000 chunks:** Use `linear` for simplicity
  - **1,000 - 100,000 chunks:** Use `ivf` for balanced performance  
  - **> 100,000 chunks:** Use `nsw` for fastest search
  
  Consider accuracy requirements:
  - **Exact results needed:** Use `linear`
  - **99%+ accuracy acceptable:** Use `ivf` with higher `n_probes`
  - **95%+ accuracy acceptable:** Use `nsw` or `ivf` with default settings
</Accordion>

<Accordion title="Metadata Usage">
  Use metadata for:
  
  - **Organization:** `{"team": "data-science", "project": "recommendation"}`
  - **Versioning:** `{"version": "2.1", "last_updated": "2024-01-15"}`
  - **Access Control:** `{"visibility": "public", "owner": "john@company.com"}`
  - **Data Lineage:** `{"source": "s3://bucket/data", "pipeline": "daily-etl"}`
</Accordion>

<Accordion title="Performance Optimization">
  For optimal performance:
  
  1. **Batch Operations:** Add many chunks before building index
  2. **Index Tuning:** Test different parameters with your data
  3. **Memory Management:** Monitor memory usage with large datasets
  4. **Build Timing:** Rebuild indexes periodically for IVF as data grows
</Accordion>
</AccordionGroup>

## Related Concepts

<CardGroup cols={2}>
  <Card
    title="Documents and Chunks"
    icon="file-text"
    href="/essentials/documents-and-chunks"
  >
    Learn how libraries contain documents and chunks for organizing your data.
  </Card>
  <Card
    title="Indexing"
    icon="chart-network"
    href="/essentials/indexing"
  >
    Deep dive into how different index types work and when to use them.
  </Card>
  <Card
    title="Searching"
    icon="magnifying-glass"
    href="/essentials/searching"
  >
    Understand how to perform vector similarity search within libraries.
  </Card>
  <Card
    title="Filtering"
    icon="filter"
    href="/essentials/filtering"
  >
    Master metadata filtering for precise search results.
  </Card>
</CardGroup>
